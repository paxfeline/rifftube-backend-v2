{"ast":null,"code":"var _jsxFileName = \"/Users/davidnewberry/Documents/test_rails/frontend/src/components/RiffControls/Record.js\";\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport { setImmediateOff } from '../../actions/index.js';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nclass Record extends React.Component {\n  constructor(props) {\n    super(props);\n    this.endRecord = () => {\n      if (this.props.recorder == null) return; // do nothing if recording isn't yet allowed\n\n      this.setState({\n        recordingState: false\n      });\n      this.duration = (Date.now() - this.startTime) / 1000;\n\n      // experimenting this.state.gumStream.getAudioTracks()[0].stop();\n      this.props.recorder.finishRecording();\n\n      // create new stream -- NEEDED???? experimenting\n      /*navigator.mediaDevices\n        .getUserMedia({ audio: true, video: false })\n        .then((stream) => {\n          this.setState({ gumStream: stream });\n        })\n        .catch(function (err) {\n          //enable the record button if getUSerMedia() fails\n          console.log(\"oops, can't get stream\", err);\n        });\n        */\n    };\n    this.startRecord = () => {\n      if (this.props.recorder == null) return; // do nothing if recording isn't yet allowed\n\n      this.setState({\n        recordingState: true\n      });\n      this.startTime = Date.now();\n      //this.state.mediaRecorder.start();\n      this.props.recorder.onComplete = (recorder, blob) => {\n        //createDownloadLink(blob, recorder.encoding);\n        this.props.saveTempAudio(blob, this.duration);\n      };\n      this.props.recorder.setOptions({\n        timeLimit: 120,\n        encodeAfterRecord: true,\n        mp3: {\n          bitRate: 160\n        }\n      });\n\n      //start the recording process\n      setTimeout(() => this.props.recorder.startRecording(), 200); // delay start to avoid clicks and taps\n    };\n    this.state = {\n      recordingState: false\n    };\n  }\n\n  // arrow classes bind the methods properly\n\n  componentDidMount() {\n    console.log(\"record CDM\", this.props.userMedia);\n    if (this.props.immediateRecord) {\n      console.log(\"start immediately\");\n      this.startRecord();\n      setImmediateOff();\n      window.addEventListener('keyup', e => {\n        if (e.key == 'r') this.endRecord();\n      });\n    }\n  }\n  render() {\n    var ret; // var for the value to be returned\n\n    if (navigator.mediaDevices) {\n      if (!this.state.recordingState) {\n        ret = /*#__PURE__*/_jsxDEV(\"button\", {\n          id: \"recordBtn\",\n          onClick: this.startRecord,\n          children: \"Record\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 80,\n          columnNumber: 11\n        }, this);\n      } else {\n        ret = /*#__PURE__*/_jsxDEV(\"button\", {\n          id: \"stopBtn\",\n          onClick: this.endRecord,\n          children: \"stop\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 89,\n          columnNumber: 11\n        }, this);\n      }\n    } else ret = /*#__PURE__*/_jsxDEV(\"span\", {\n      children: \"Your device is not supported by navigator.mediaDevices. Sorry.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 99,\n      columnNumber: 9\n    }, this);\n    return /*#__PURE__*/_jsxDEV(React.Fragment, {\n      children: ret\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 104,\n      columnNumber: 12\n    }, this);\n  }\n}\nconst mapStateToProps = state => ({\n  immediateRecord: state.immediateRecord,\n  recorder: state.recorder\n});\nconst mapDispatchToProps = {\n  setImmediateOff\n};\nexport default connect(mapStateToProps, mapDispatchToProps)(Record);","map":{"version":3,"names":["React","connect","setImmediateOff","Record","Component","constructor","props","endRecord","recorder","setState","recordingState","duration","Date","now","startTime","finishRecording","startRecord","onComplete","blob","saveTempAudio","setOptions","timeLimit","encodeAfterRecord","mp3","bitRate","setTimeout","startRecording","state","componentDidMount","console","log","userMedia","immediateRecord","window","addEventListener","e","key","render","ret","navigator","mediaDevices","mapStateToProps","mapDispatchToProps"],"sources":["/Users/davidnewberry/Documents/test_rails/frontend/src/components/RiffControls/Record.js"],"sourcesContent":["import React from 'react';\nimport { connect } from 'react-redux';\nimport {\n  setImmediateOff,\n} from '../../actions/index.js';\n\nclass Record extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      recordingState: false,\n    };\n  }\n\n  // arrow classes bind the methods properly\n\n  endRecord = () => {\n    if (this.props.recorder == null) return; // do nothing if recording isn't yet allowed\n\n    this.setState({ recordingState: false });\n    this.duration = (Date.now() - this.startTime) / 1000;\n\n    // experimenting this.state.gumStream.getAudioTracks()[0].stop();\n    this.props.recorder.finishRecording();\n\n    // create new stream -- NEEDED???? experimenting\n    /*navigator.mediaDevices\n      .getUserMedia({ audio: true, video: false })\n      .then((stream) => {\n        this.setState({ gumStream: stream });\n      })\n      .catch(function (err) {\n        //enable the record button if getUSerMedia() fails\n        console.log(\"oops, can't get stream\", err);\n      });\n      */\n  }\n\n  componentDidMount() {\n    console.log(\"record CDM\", this.props.userMedia);\n    if ( this.props.immediateRecord )\n    {\n      console.log(\"start immediately\");\n      this.startRecord();\n      setImmediateOff();\n      window.addEventListener('keyup', (e) => { if (e.key == 'r') this.endRecord(); });\n    }\n  }\n\n\n  startRecord = () => {\n    if (this.props.recorder == null) return; // do nothing if recording isn't yet allowed\n\n    this.setState({ recordingState: true });\n    this.startTime = Date.now();\n    //this.state.mediaRecorder.start();\n    this.props.recorder.onComplete = (recorder, blob) => {\n      //createDownloadLink(blob, recorder.encoding);\n      this.props.saveTempAudio(blob, this.duration);\n    };\n    this.props.recorder.setOptions({\n      timeLimit: 120,\n      encodeAfterRecord: true,\n      mp3: {\n        bitRate: 160,\n      },\n    });\n\n    //start the recording process\n    setTimeout( () => this.props.recorder.startRecording(), 200 ); // delay start to avoid clicks and taps\n  }\n\n  render() {\n    var ret; // var for the value to be returned\n\n    if (navigator.mediaDevices) {\n      if (!this.state.recordingState) {\n        ret = (\n          <button\n            id=\"recordBtn\"\n            onClick={this.startRecord}\n          >\n            Record\n          </button>\n        );\n      } else {\n        ret = (\n          <button\n            id=\"stopBtn\"\n            onClick={this.endRecord}\n          >\n            stop\n          </button>\n        );\n      }\n    } else\n      ret = (\n        <span>\n          Your device is not supported by navigator.mediaDevices. Sorry.\n        </span>\n      );\n\n    return <React.Fragment>{ret}</React.Fragment>;\n  }\n}\n\n\n\nconst mapStateToProps = (state) => ({\n  immediateRecord: state.immediateRecord,\n  recorder: state.recorder,\n});\n\nconst mapDispatchToProps = {\n  setImmediateOff,\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Record);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}