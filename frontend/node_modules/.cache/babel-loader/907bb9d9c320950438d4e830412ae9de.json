{"ast":null,"code":"import _toConsumableArray from\"/Users/davidnewberry/Documents/test_rails/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _createForOfIteratorHelper from\"/Users/davidnewberry/Documents/test_rails/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _classCallCheck from\"/Users/davidnewberry/Documents/test_rails/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/Users/davidnewberry/Documents/test_rails/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";import _inherits from\"/Users/davidnewberry/Documents/test_rails/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";import _createSuper from\"/Users/davidnewberry/Documents/test_rails/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";import React from'react';import YouTubeVideo from'../YouTubeVideo/YouTubeVideo';var ViewFilter=/*#__PURE__*/function(_React$Component){_inherits(ViewFilter,_React$Component);var _super=_createSuper(ViewFilter);function ViewFilter(props){var _this;_classCallCheck(this,ViewFilter);_this=_super.call(this,props);// window.metaPlayhead gets updated by the youtube component\n_this.selectRiff=function(newRiff){// use id to find riff in \"master\" list\n//const riff = this.props.riffs.find( r => r.id == selected_id );\nvar riff;if(_this.state.nonOverlappingRiffs.has(riff))return;var selectedRiffs=new Set(_this.state.selectedRiffs);var newFiltered=new Set(_this.props.riffs);var otherOverlaps=new Set();//new Set( this.state.overlappingRiffs );\n_this.state.overlappingRiffs.forEach(function(el){return otherOverlaps.add(new Set(el));});riff=newRiff;do{// go through each set of overlapping riffs\nvar _iterator=_createForOfIteratorHelper(_this.state.overlappingRiffs),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var set=_step.value;// if that set contains the selected riff, remove all its values from the\nif(set.has(riff)){set.forEach(function(el){selectedRiffs.delete(el);newFiltered.delete(el);});}}}catch(err){_iterator.e(err);}finally{_iterator.f();}selectedRiffs.add(riff);// now the hard part\nvar _iterator2=_createForOfIteratorHelper(selectedRiffs),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var r=_step2.value;// find and delete sets of overlap that contain a selected riff\nvar toDelete=[];var _iterator4=_createForOfIteratorHelper(otherOverlaps),_step4;try{for(_iterator4.s();!(_step4=_iterator4.n()).done;){var _set2=_step4.value;if(_set2.has(r)){toDelete.push(_set2);}}}catch(err){_iterator4.e(err);}finally{_iterator4.f();}for(var _i=0,_toDelete=toDelete;_i<_toDelete.length;_i++){var _set=_toDelete[_i];otherOverlaps.delete(_set);// from the sets in question, remove all their riffs from other overlap sets\n// (because they are no longer valid options)\nvar curOverlap=new Set();var _iterator5=_createForOfIteratorHelper(otherOverlaps),_step5;try{for(_iterator5.s();!(_step5=_iterator5.n()).done;){var redu=_step5.value;var _iterator6=_createForOfIteratorHelper(_set),_step6;try{for(_iterator6.s();!(_step6=_iterator6.n()).done;){var tod=_step6.value;newFiltered.delete(tod);redu.delete(tod);}}catch(err){_iterator6.e(err);}finally{_iterator6.f();}}}catch(err){_iterator5.e(err);}finally{_iterator5.f();}}}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}var _iterator3=_createForOfIteratorHelper(otherOverlaps),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var _redu=_step3.value;if(_redu.size>0)curOverlap=new Set([].concat(_toConsumableArray(curOverlap),_toConsumableArray(_redu)));}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}if(curOverlap.size>0)riff=curOverlap.values().next().value;}while(curOverlap.size>0);// generate final filtered list\nvar filteredRiffs=[].concat(_toConsumableArray(newFiltered),_toConsumableArray(selectedRiffs));_this.setState({filteredRiffs:filteredRiffs,selectedRiffs:selectedRiffs});};window.metaPlayHead=React.createRef();_this.selectDiv=React.createRef();window.metaUpdate=function(el){if(_this.selectDiv.current)// seems like it shouldn't be needed, but here we are\n_this.selectDiv.current.scrollLeft=el.offsetLeft-_this.selectDiv.current.offsetWidth/2;};_this.state={filteredRiffs:[],overlappingRiffs:[],nonOverlappingRiffs:null,selectedRiffs:null,tracks:[]};// filtered riffs is the final result\n// overlapping riffs is a list of sets [of ids] of overlapping riffs\n// selected riffs is a set\n// tracks are used for the UI\nreturn _this;}_createClass(ViewFilter,[{key:\"componentDidUpdate\",value:function componentDidUpdate(prevProps){if(prevProps.riffs!==this.props.riffs){debugger;// if riffs have changed, we need to recalculate\n// multiple tracks are used to display overlapping riffs at the same time\nvar tracks=[[]];var trackPos=[0];// time code where last riff on track ends\nvar nonOverlappingRiffs=new Set();// used to keep track of conflicting riffs\nvar runningRiffs=[];// these will overwrite the current values after being built\nvar overlappingRiffs=[];var selectedRiffs=new Set();// slope basically means \"was the last action to add or remove from the running list\"\nvar slope=0;// sort riffs by starting time\nthis.props.riffs.sort(function(e1,e2){return e1.time-e2.time;});// loop through sorted riffs\nvar _iterator7=_createForOfIteratorHelper(this.props.riffs),_step7;try{for(_iterator7.s();!(_step7=_iterator7.n()).done;){var riff=_step7.value;// check to see if any riffs end before this riff starts\nif(runningRiffs.length>0){// this could be optimized by first sorting running set\nvar toDelete=[];var _iterator9=_createForOfIteratorHelper(runningRiffs),_step9;try{for(_iterator9.s();!(_step9=_iterator9.n()).done;){var toCheck=_step9.value;// (see above)\nif(toCheck.time+toCheck.duration<=riff.time){// only add set if the prev action was an add,\n// and there is more than 1 riff in the set\nif(slope>0&&runningRiffs.length>1){overlappingRiffs.push(new Set(runningRiffs));// when adding overlapping set, find if any are in track 0\n// if so, they go into selectedRiffs\nvar _iterator10=_createForOfIteratorHelper(runningRiffs),_step10;try{for(_iterator10.s();!(_step10=_iterator10.n()).done;){var _candi=_step10.value;if(tracks[0].includes(_candi)){selectedRiffs.add(_candi);break;}}}catch(err){_iterator10.e(err);}finally{_iterator10.f();}}else if(slope>0){// 'if' part may be unnecessary\nnonOverlappingRiffs.add(toCheck);}// don't delete in place while looping\ntoDelete.push(toCheck);slope=-1;// last action was to remove\n}}}catch(err){_iterator9.e(err);}finally{_iterator9.f();}for(var _i2=0,_toDelete2=toDelete;_i2<_toDelete2.length;_i2++){var el=_toDelete2[_i2];runningRiffs.splice(runningRiffs.indexOf(el),1);}}// add this riff to running list\nrunningRiffs.push(riff);// keep running list sorted by first ending\nrunningRiffs.sort(function(e1,e2){return e1.time+e1.duration-(e2.time+e2.duration);});// last action was to add\nslope=1;// assign riff to a track\nvar flag=true;for(var i=0;i<tracks.length;i++){// check whether this track is available\nif(trackPos[i]<=riff.time){tracks[i].push(riff);trackPos[i]=riff.time+riff.duration;flag=false;break;}}// if no track was found, add one\nif(flag){tracks.push([riff]);trackPos.push(riff.time+riff.duration);}}// cleanup after loop\n// check to see if running set has more than 1 riff\n// if so, add it etc.\n}catch(err){_iterator7.e(err);}finally{_iterator7.f();}if(runningRiffs.length>1){overlappingRiffs.push(new Set(runningRiffs));var _iterator8=_createForOfIteratorHelper(runningRiffs),_step8;try{for(_iterator8.s();!(_step8=_iterator8.n()).done;){var candi=_step8.value;if(tracks[0].includes(candi)){selectedRiffs.add(candi);break;}}}catch(err){_iterator8.e(err);}finally{_iterator8.f();}}else nonOverlappingRiffs.add(runningRiffs[0]);var filteredRiffs=_toConsumableArray(tracks[0]);this.setState({filteredRiffs:filteredRiffs,overlappingRiffs:overlappingRiffs,nonOverlappingRiffs:nonOverlappingRiffs,selectedRiffs:selectedRiffs,tracks:tracks});}}},{key:\"render\",value:function render(){var _this2=this;return/*#__PURE__*/React.createElement(React.Fragment,null,/*#__PURE__*/React.createElement(YouTubeVideo,{id:this.props.id,riffs:this.state.filteredRiffs}),/*#__PURE__*/React.createElement(\"div\",{ref:this.selectDiv,style:{fontSize:'2em',overflow:'hidden',width:'640px'}},/*#__PURE__*/React.createElement(\"div\",{style:{height:\"\".concat(this.state.tracks.length*0.75,\"em\"),width:\"\".concat(this.props.duration,\"em\"),position:'relative'}},/*#__PURE__*/React.createElement(\"div\",{id:\"meta-play-head\",style:{backgroundColor:'red',height:'inherit'},ref:window.metaPlayHead}),this.state.tracks.map(function(trackArray){return/*#__PURE__*/React.createElement(\"div\",{style:{width:\"\".concat(_this2.props.duration,\"em\"),height:'0.75em'}},trackArray.map(function(riff){return/*#__PURE__*/React.createElement(\"div\",{style:{position:'absolute',overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap',fontSize:'0.25em',lineHeight:'3em',verticalAlign:'middle',left:\"\".concat(riff.time*4,\"em\"),height:'3em',width:\"\".concat(riff.duration*4,\"em\"),backgroundColor:_this2.state.filteredRiffs.includes(riff)?'red':'lightgrey'},onClick:function onClick(){return _this2.selectRiff(riff);}},riff.name);}));}))));}}]);return ViewFilter;}(React.Component);export default ViewFilter;","map":{"version":3,"names":["React","YouTubeVideo","ViewFilter","props","selectRiff","newRiff","riff","state","nonOverlappingRiffs","has","selectedRiffs","Set","newFiltered","riffs","otherOverlaps","overlappingRiffs","forEach","el","add","set","delete","r","toDelete","push","curOverlap","redu","tod","size","values","next","value","filteredRiffs","setState","window","metaPlayHead","createRef","selectDiv","metaUpdate","current","scrollLeft","offsetLeft","offsetWidth","tracks","prevProps","trackPos","runningRiffs","slope","sort","e1","e2","time","length","toCheck","duration","candi","includes","splice","indexOf","flag","i","id","fontSize","overflow","width","height","position","backgroundColor","map","trackArray","textOverflow","whiteSpace","lineHeight","verticalAlign","left","name","Component"],"sources":["/Users/davidnewberry/Documents/test_rails/frontend/src/components/ViewInterface/ViewFilter.js"],"sourcesContent":["import React from 'react';\nimport YouTubeVideo from '../YouTubeVideo/YouTubeVideo';\n\nclass ViewFilter extends React.Component {\n  constructor(props) {\n    super(props);\n    // window.metaPlayhead gets updated by the youtube component\n    window.metaPlayHead = React.createRef();\n    this.selectDiv = React.createRef();\n    window.metaUpdate = (el) => {\n      if (this.selectDiv.current)\n        // seems like it shouldn't be needed, but here we are\n        this.selectDiv.current.scrollLeft =\n          el.offsetLeft - this.selectDiv.current.offsetWidth / 2;\n    };\n\n    this.state = {\n      filteredRiffs: [],\n      overlappingRiffs: [],\n      nonOverlappingRiffs: null,\n      selectedRiffs: null,\n      tracks: [],\n    };\n    // filtered riffs is the final result\n    // overlapping riffs is a list of sets [of ids] of overlapping riffs\n    // selected riffs is a set\n    // tracks are used for the UI\n  }\n\n  selectRiff = (newRiff) => {\n    // use id to find riff in \"master\" list\n    //const riff = this.props.riffs.find( r => r.id == selected_id );\n    let riff;\n    if (this.state.nonOverlappingRiffs.has(riff)) return;\n\n    const selectedRiffs = new Set(this.state.selectedRiffs);\n\n    const newFiltered = new Set(this.props.riffs);\n\n    const otherOverlaps = new Set(); //new Set( this.state.overlappingRiffs );\n    this.state.overlappingRiffs.forEach((el) => otherOverlaps.add(new Set(el)));\n\n    riff = newRiff;\n\n    do {\n      // go through each set of overlapping riffs\n      for (const set of this.state.overlappingRiffs) {\n        // if that set contains the selected riff, remove all its values from the\n        if (set.has(riff)) {\n          set.forEach((el) => {\n            selectedRiffs.delete(el);\n            newFiltered.delete(el);\n          });\n        }\n      }\n\n      selectedRiffs.add(riff);\n\n      // now the hard part\n\n      for (const r of selectedRiffs) {\n        // find and delete sets of overlap that contain a selected riff\n        const toDelete = [];\n        for (const set of otherOverlaps) {\n          if (set.has(r)) {\n            toDelete.push(set);\n          }\n        }\n        for (const set of toDelete) {\n          otherOverlaps.delete(set);\n          // from the sets in question, remove all their riffs from other overlap sets\n          // (because they are no longer valid options)\n          var curOverlap = new Set();\n          for (const redu of otherOverlaps) {\n            for (const tod of set) {\n              newFiltered.delete(tod);\n              redu.delete(tod);\n            }\n          }\n        }\n      }\n      for (const redu of otherOverlaps) {\n        if (redu.size > 0) curOverlap = new Set([...curOverlap, ...redu]);\n      }\n\n      if (curOverlap.size > 0) riff = curOverlap.values().next().value;\n    } while (curOverlap.size > 0);\n\n    // generate final filtered list\n    const filteredRiffs = [...newFiltered, ...selectedRiffs];\n\n    this.setState({ filteredRiffs, selectedRiffs });\n  };\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.riffs !== this.props.riffs) {\n      debugger;\n\n      // if riffs have changed, we need to recalculate\n\n      // multiple tracks are used to display overlapping riffs at the same time\n      const tracks = [[]];\n      const trackPos = [0]; // time code where last riff on track ends\n\n      const nonOverlappingRiffs = new Set();\n\n      // used to keep track of conflicting riffs\n      const runningRiffs = [];\n\n      // these will overwrite the current values after being built\n      const overlappingRiffs = [];\n      const selectedRiffs = new Set();\n\n      // slope basically means \"was the last action to add or remove from the running list\"\n      var slope = 0;\n\n      // sort riffs by starting time\n      this.props.riffs.sort((e1, e2) => e1.time - e2.time);\n\n      // loop through sorted riffs\n      for (const riff of this.props.riffs) {\n        // check to see if any riffs end before this riff starts\n        if (runningRiffs.length > 0) {\n          // this could be optimized by first sorting running set\n          const toDelete = [];\n          for (const toCheck of runningRiffs) {\n            // (see above)\n            if (toCheck.time + toCheck.duration <= riff.time) {\n              // only add set if the prev action was an add,\n              // and there is more than 1 riff in the set\n              if (slope > 0 && runningRiffs.length > 1) {\n                overlappingRiffs.push(new Set(runningRiffs));\n\n                // when adding overlapping set, find if any are in track 0\n                // if so, they go into selectedRiffs\n                for (const candi of runningRiffs) {\n                  if (tracks[0].includes(candi)) {\n                    selectedRiffs.add(candi);\n                    break;\n                  }\n                }\n              } else if (slope > 0) {\n                // 'if' part may be unnecessary\n                nonOverlappingRiffs.add(toCheck);\n              }\n\n              // don't delete in place while looping\n              toDelete.push(toCheck);\n              slope = -1; // last action was to remove\n            }\n          }\n          for (const el of toDelete)\n            runningRiffs.splice(runningRiffs.indexOf(el), 1);\n        }\n\n        // add this riff to running list\n        runningRiffs.push(riff);\n\n        // keep running list sorted by first ending\n        runningRiffs.sort(\n          (e1, e2) => e1.time + e1.duration - (e2.time + e2.duration)\n        );\n\n        // last action was to add\n        slope = 1;\n\n        // assign riff to a track\n        var flag = true;\n        for (var i = 0; i < tracks.length; i++) {\n          // check whether this track is available\n          if (trackPos[i] <= riff.time) {\n            tracks[i].push(riff);\n            trackPos[i] = riff.time + riff.duration;\n            flag = false;\n            break;\n          }\n        }\n\n        // if no track was found, add one\n        if (flag) {\n          tracks.push([riff]);\n          trackPos.push(riff.time + riff.duration);\n        }\n      }\n\n      // cleanup after loop\n      // check to see if running set has more than 1 riff\n      // if so, add it etc.\n      if (runningRiffs.length > 1) {\n        overlappingRiffs.push(new Set(runningRiffs));\n\n        for (const candi of runningRiffs) {\n          if (tracks[0].includes(candi)) {\n            selectedRiffs.add(candi);\n            break;\n          }\n        }\n      } else nonOverlappingRiffs.add(runningRiffs[0]);\n\n      const filteredRiffs = [...tracks[0]];\n\n      this.setState({\n        filteredRiffs,\n        overlappingRiffs,\n        nonOverlappingRiffs,\n        selectedRiffs,\n        tracks,\n      });\n    }\n  }\n\n  render() {\n    return (\n      <React.Fragment>\n        <YouTubeVideo id={this.props.id} riffs={this.state.filteredRiffs} />\n        <div\n          ref={this.selectDiv}\n          style={{ fontSize: '2em', overflow: 'hidden', width: '640px' }}\n        >\n          <div\n            style={{\n              height: `${this.state.tracks.length * 0.75}em`,\n              width: `${this.props.duration}em`,\n              position: 'relative',\n            }}\n          >\n            <div\n              id=\"meta-play-head\"\n              style={{ backgroundColor: 'red', height: 'inherit' }}\n              ref={window.metaPlayHead}\n            />\n            {this.state.tracks.map((trackArray) => (\n              <div\n                style={{ width: `${this.props.duration}em`, height: '0.75em' }}\n              >\n                {trackArray.map((riff) => (\n                  <div\n                    style={{\n                      position: 'absolute',\n                      overflow: 'hidden',\n                      textOverflow: 'ellipsis',\n                      whiteSpace: 'nowrap',\n                      fontSize: '0.25em',\n                      lineHeight: '3em',\n                      verticalAlign: 'middle',\n                      left: `${riff.time * 4}em`,\n                      height: '3em',\n                      width: `${riff.duration * 4}em`,\n                      backgroundColor: this.state.filteredRiffs.includes(riff)\n                        ? 'red'\n                        : 'lightgrey',\n                    }}\n                    onClick={() => this.selectRiff(riff)}\n                  >\n                    {riff.name}\n                  </div>\n                ))}\n              </div>\n            ))}\n          </div>\n        </div>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default ViewFilter;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}