{"ast":null,"code":"import _createClass from\"/Users/davidnewberry/Documents/test_rails/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";import _classCallCheck from\"/Users/davidnewberry/Documents/test_rails/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _inherits from\"/Users/davidnewberry/Documents/test_rails/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";import _createSuper from\"/Users/davidnewberry/Documents/test_rails/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";import React from'react';import{connect}from'react-redux';import{setPlayerMode,setRiffPlaying,loadRiff,togglePlayerMode,setVideoDuration,EDIT_MODE,EDIT_NEW_MODE,PLAY_MODE,PAUSE_MODE}from'../../actions/index.js';import AllowPlayback from'./AllowPlayback.js';// based on https://stackoverflow.com/questions/54017100/how-to-integrate-youtube-iframe-api-in-reactjs-solution\nvar YouTubeVideo=/*#__PURE__*/function(_React$Component){_inherits(YouTubeVideo,_React$Component);var _super=_createSuper(YouTubeVideo);function YouTubeVideo(){var _this;_classCallCheck(this,YouTubeVideo);for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_super.call.apply(_super,[this].concat(args));_this.componentDidMount=function(){// On mount, check to see if the API script is already loaded\nif(!window.YT||!window.YT.Player){// If not, load the script asynchronously\nvar tag=document.createElement('script');tag.src='https://www.youtube.com/iframe_api';// onYouTubeIframeAPIReady will load the video after the script is loaded\nwindow.onYouTubeIframeAPIReady=_this.loadVideo;var firstScriptTag=document.getElementsByTagName('script')[0];firstScriptTag.parentNode.insertBefore(tag,firstScriptTag);}// If script is already there, load the video directly\nelse{_this.loadVideo();_this.checkForRiffsToLoad(0);// check if any riffs at < 10s in need loading\n}};_this.loadVideo=function(){if(!window.YT)return;// can be called by componentDidUpdate before window.YT has loaded\nvar id=_this.props.id;if(window.rifftubePlayer)window.rifftubePlayer.destroy();_this.player=new window.YT.Player('rifftube-player',{videoId:id,height:390,width:640,playerVars:{playsinline:1// allows it to play inline on iOS\n},events:{onReady:_this.onPlayerReady,onStateChange:_this.onPlayerStateChange}});window.rifftubePlayer=_this.player;// store global reference (used to get current playback time when needed)\n};_this.onPlayerReady=function(event){//event.target.playVideo();\n_this.props.setVideoDuration(event.target.getDuration());};_this.checkForRiffsToLoad=function(t){_this.props.riffs.forEach(function(riff){if(// if no id, it's being saved\nriff.id&&//if it's an audio riff\nriff.type==='audio'&&//if it's not loaded already\n!_this.props.riffsAudio.all[riff.id]&&//!riff.payload &&\n//if it's not loading\n!_this.props.riffsAudio.loading[riff.id]&&//!riff.loading &&\n// if the riff is in the future\nriff.time>=t&&// but is less than 10 seconds in the future\nriff.time<t+10)// load the riff to be played at the right time\n_this.props.loadRiff(riff.id);});};_this.onPlayerStateChange=function(_ref){var data=_ref.data;/*\n        -1 (unstarted)\n        0 (ended)\n        1 (playing)\n        2 (paused)\n        3 (buffering)\n        5 (video cued).\n        */ // the following conditional leaves out some 'else's that should never occur\nif(data===1){// playing\n// the following code is\n// needed I think... for pausing during a riff.\n// so that (subsiquent) 'zombie' riffs can be killed,\n// I think.\n_this.curRiff=_this.props.riffsPlaying;/*******************************************************/ // this timer is responsible for showing and hiding riffs\n_this.riffInterval=setInterval(function(){if(!(window.rifftubePlayer&&typeof window.rifftubePlayer.getCurrentTime=='function'))return;var t=window.rifftubePlayer.getCurrentTime();// if the MetaBar component exists, update its playhead\nif(window.metaPlayHead&&window.metaPlayHead.current){window.metaPlayHead.current.style.left=\"\".concat(t/_this.props.duration*100,\"%\");if(window.metaUpdate)window.metaUpdate(window.metaPlayHead.current);}//\n_this.checkForRiffsToLoad(t);// first stop any zombie riffs\n_this.props.riffs.forEach(function(riff,index){if(_this.curRiff[index]&&(t<riff.time||t>riff.time+riff.duration)){if(_this.curRiff[index].inUse)_this.curRiff[index].inUse=false;// by setting this to false, text riffs will be hidden\n_this.props.setRiffPlaying(index,false);_this.curRiff[index]=null;if(riff.type==='audio')// make sure all audio clips have stopped\n_this.audLock--;if(!_this.audLock){window.rifftubePlayer.setVolume(_this.vol?_this.vol:100);// hopefully unnecessary volume failsafe\ndelete _this.vol;}}});// next start any that should be playing\n_this.props.riffs.forEach(function(riff,index){// the riff will start playing within half a second, or will be skipped\nif(!_this.curRiff[index]&&t>riff.time&&t<riff.time+0.5){_this.props.setRiffPlaying(index,true);_this.curRiff[index]=true;// used for text only; overwritten for audio\nif(riff.type==='audio'){if(!_this.vol){_this.vol=window.rifftubePlayer.getVolume();window.rifftubePlayer.setVolume(_this.vol*0.25);}// keeps track of how many audio tracks need to end before volume should be restored\nif(!_this.audLock)_this.audLock=1;else _this.audLock++;if(!_this.props.riffsAudio.all[riff.id]){//(!riff.payload) {\nreturn;}// DEBUG - SHOULD BE REMOVED\nvar audioURL=URL.createObjectURL(_this.props.riffsAudio.all[riff.id]);//(riff.payload);\n//debugger;\nwindow.lastRiff=_this.props.riffsAudio.all[riff.id];// riff.payload;\n// FIX THIS:\nfor(var i=0;i<window.audioPlayersCount;i++){/*\n                if ( window.audioContexts[i].inUse ) continue;\n                let audioContext = window.audioContexts[i];\n                window.audioContexts[i].inUse = true;\n                var blob = riff.payload;\n                new Response(blob).arrayBuffer().then(function(arrayBuffer) {\n                  window.audioContexts[0].decodeAudioData(arrayBuffer, audioData => {\n                    debugger;\n                    var source = window.audioContexts[i].createBufferSource();\n                    source.buffer = audioData;\n                    source.connect(window.audioContexts[i].destination);\n                    source.start()\n                  })\n                });\n                */var audio=window.audioPlayers[i];if(audio.inUse)continue;audio.inUse=true;// TEST:\naudio.srcEl.src=audioURL;audio.load();audio.play();/*\n                var se = document.createElement('source');\n                audio.appendChild(se);\n                se.src = audioURL;\n                //se.type = 'audio/webm';\n                audio.load();\n                audio.play();\n                */ // ORIG:\n/*\n                audio.src = audioURL;\n                audio.play();\n                */_this.curRiff[index]=audio;// audioContext;\nbreak;}}}});},100);// 100/1000 = 1/10 s\nif(_this.props.mode!==PLAY_MODE){// change mode state\n_this.props.setPlayerMode(PLAY_MODE);}}// not playing\nelse{// stop riff-check interval when not playing\nclearInterval(_this.riffInterval);if(_this.props.mode===PLAY_MODE){// change mode state\n_this.props.setPlayerMode(PAUSE_MODE);}}};_this.componentDidUpdate=function(prevProps){// seems needed on more than just mounting\n// (makes sense; the riff meta takes some time to load)\n_this.checkForRiffsToLoad(0);// check if any riffs at < 10s in need loading\nif(_this.props.id!==prevProps.id)_this.loadVideo();if(!(_this.player&&_this.player.getPlayerState))return;if(_this.props.mode!==prevProps.mode){if((_this.props.mode===EDIT_MODE||_this.props.mode===EDIT_NEW_MODE||_this.props.mode===PAUSE_MODE)&&_this.player.getPlayerState()===1){_this.player.pauseVideo();}else if(_this.props.mode===PLAY_MODE&&_this.player.getPlayerState()!==1){_this.player.playVideo();}}};_this.render=function(){return/*#__PURE__*/React.createElement(React.Fragment,null,/*#__PURE__*/React.createElement(\"div\",{className:\"rifftube-container\"},/*#__PURE__*/React.createElement(AllowPlayback,null),/*#__PURE__*/React.createElement(\"div\",{className:\"rifftube-overlay\"},/*#__PURE__*/React.createElement(\"div\",{className:\"rifftube-riffs-container\"},Object.keys(_this.props.riffsPlaying).filter(function(i){return _this.props.riffsPlaying[i]&&_this.props.riffs[i]&&_this.props.riffs[i].type==='text';}).map(function(key){return/*#__PURE__*/React.createElement(\"div\",{key:_this.props.riffs[key].id,className:\"rifftube-textriff\"},_this.props.riffs[key].payload);}))),/*#__PURE__*/React.createElement(\"div\",{id:\"rifftube-player\"})));};return _this;}return _createClass(YouTubeVideo);}(React.Component);var mapStateToProps=function mapStateToProps(state){return{mode:state.mode,//riffs: state.riffs.all,\nriffsPlaying:state.riffsPlaying,googleUser:state.googleUser,duration:state.duration,riffsAudio:state.riffsAudio};};var mapDispatchToProps={setPlayerMode:setPlayerMode,setRiffPlaying:setRiffPlaying,togglePlayerMode:togglePlayerMode,loadRiff:loadRiff,setVideoDuration:setVideoDuration};export default connect(mapStateToProps,mapDispatchToProps)(YouTubeVideo);","map":{"version":3,"names":["React","connect","setPlayerMode","setRiffPlaying","loadRiff","togglePlayerMode","setVideoDuration","EDIT_MODE","EDIT_NEW_MODE","PLAY_MODE","PAUSE_MODE","AllowPlayback","YouTubeVideo","componentDidMount","window","YT","Player","tag","document","createElement","src","onYouTubeIframeAPIReady","loadVideo","firstScriptTag","getElementsByTagName","parentNode","insertBefore","checkForRiffsToLoad","id","props","rifftubePlayer","destroy","player","videoId","height","width","playerVars","playsinline","events","onReady","onPlayerReady","onStateChange","onPlayerStateChange","event","target","getDuration","t","riffs","forEach","riff","type","riffsAudio","all","loading","time","data","curRiff","riffsPlaying","riffInterval","setInterval","getCurrentTime","metaPlayHead","current","style","left","duration","metaUpdate","index","inUse","audLock","setVolume","vol","getVolume","audioURL","URL","createObjectURL","lastRiff","i","audioPlayersCount","audio","audioPlayers","srcEl","load","play","mode","clearInterval","componentDidUpdate","prevProps","getPlayerState","pauseVideo","playVideo","render","Object","keys","filter","map","key","payload","Component","mapStateToProps","state","googleUser","mapDispatchToProps"],"sources":["/Users/davidnewberry/Documents/test_rails/frontend/src/components/YouTubeVideo/YouTubeVideo.js"],"sourcesContent":["import React from 'react';\nimport { connect } from 'react-redux';\nimport {\n  setPlayerMode,\n  setRiffPlaying,\n  loadRiff,\n  togglePlayerMode,\n  setVideoDuration,\n  EDIT_MODE,\n  EDIT_NEW_MODE,\n  PLAY_MODE,\n  PAUSE_MODE,\n} from '../../actions/index.js';\nimport AllowPlayback from './AllowPlayback.js';\n\n// based on https://stackoverflow.com/questions/54017100/how-to-integrate-youtube-iframe-api-in-reactjs-solution\n\nclass YouTubeVideo extends React.Component {\n  componentDidMount = () => {\n    // On mount, check to see if the API script is already loaded\n\n    if (!window.YT || !window.YT.Player) {\n      // If not, load the script asynchronously\n      const tag = document.createElement('script');\n      tag.src = 'https://www.youtube.com/iframe_api';\n\n      // onYouTubeIframeAPIReady will load the video after the script is loaded\n      window.onYouTubeIframeAPIReady = this.loadVideo;\n\n      const firstScriptTag = document.getElementsByTagName('script')[0];\n      firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\n    } // If script is already there, load the video directly\n    else {\n      this.loadVideo();\n      this.checkForRiffsToLoad(0); // check if any riffs at < 10s in need loading\n    }\n  };\n\n  loadVideo = () => {\n    if (!window.YT) return; // can be called by componentDidUpdate before window.YT has loaded\n\n    const { id } = this.props;\n\n    if (window.rifftubePlayer) window.rifftubePlayer.destroy();\n\n    this.player = new window.YT.Player('rifftube-player', {\n      videoId: id,\n      height: 390,\n      width: 640,\n      playerVars: {\n        playsinline: 1, // allows it to play inline on iOS\n      },\n      events: {\n        onReady: this.onPlayerReady,\n        onStateChange: this.onPlayerStateChange,\n      },\n    });\n\n    window.rifftubePlayer = this.player; // store global reference (used to get current playback time when needed)\n  };\n\n  onPlayerReady = (event) => {\n    //event.target.playVideo();\n\n    this.props.setVideoDuration(event.target.getDuration());\n  };\n\n  // TODO: account for muted riffs!!!!\n  checkForRiffsToLoad = (t) => {\n    this.props.riffs.forEach((riff) => {\n      if (\n        // if no id, it's being saved\n        riff.id &&\n        //if it's an audio riff\n        riff.type === 'audio' &&\n        //if it's not loaded already\n        !this.props.riffsAudio.all[riff.id] && //!riff.payload &&\n        //if it's not loading\n        !this.props.riffsAudio.loading[riff.id] && //!riff.loading &&\n        // if the riff is in the future\n        riff.time >= t &&\n        // but is less than 10 seconds in the future\n        riff.time < t + 10\n      )\n        // load the riff to be played at the right time\n        this.props.loadRiff(riff.id);\n    });\n  };\n\n  onPlayerStateChange = ({ data }) => {\n    /*\n        -1 (unstarted)\n        0 (ended)\n        1 (playing)\n        2 (paused)\n        3 (buffering)\n        5 (video cued).\n        */\n\n    // the following conditional leaves out some 'else's that should never occur\n\n    if (data === 1) {\n      // playing\n\n      // the following code is\n      // needed I think... for pausing during a riff.\n      // so that (subsiquent) 'zombie' riffs can be killed,\n      // I think.\n      this.curRiff = this.props.riffsPlaying;\n\n      /*******************************************************/\n      // this timer is responsible for showing and hiding riffs\n      this.riffInterval = setInterval(() => {\n        if (\n          !(\n            window.rifftubePlayer &&\n            typeof window.rifftubePlayer.getCurrentTime == 'function'\n          )\n        )\n          return;\n\n        let t = window.rifftubePlayer.getCurrentTime();\n\n        // if the MetaBar component exists, update its playhead\n        if (window.metaPlayHead && window.metaPlayHead.current) {\n          window.metaPlayHead.current.style.left = `${\n            (t / this.props.duration) * 100\n          }%`;\n          if (window.metaUpdate) window.metaUpdate(window.metaPlayHead.current);\n        }\n\n        //\n        this.checkForRiffsToLoad(t);\n\n        // first stop any zombie riffs\n        this.props.riffs.forEach((riff, index) => {\n          if (\n            this.curRiff[index] &&\n            (t < riff.time || t > riff.time + riff.duration)\n          ) {\n            if (this.curRiff[index].inUse) this.curRiff[index].inUse = false;\n\n            // by setting this to false, text riffs will be hidden\n            this.props.setRiffPlaying(index, false);\n            this.curRiff[index] = null;\n\n            if (riff.type === 'audio')\n              // make sure all audio clips have stopped\n              this.audLock--;\n            if (!this.audLock) {\n              window.rifftubePlayer.setVolume(this.vol ? this.vol : 100); // hopefully unnecessary volume failsafe\n              delete this.vol;\n            }\n          }\n        });\n\n        // next start any that should be playing\n        this.props.riffs.forEach((riff, index) => {\n          // the riff will start playing within half a second, or will be skipped\n          if (!this.curRiff[index] && t > riff.time && t < riff.time + 0.5) {\n            this.props.setRiffPlaying(index, true);\n            this.curRiff[index] = true; // used for text only; overwritten for audio\n\n            if (riff.type === 'audio') {\n              if (!this.vol) {\n                this.vol = window.rifftubePlayer.getVolume();\n                window.rifftubePlayer.setVolume(this.vol * 0.25);\n              }\n\n              // keeps track of how many audio tracks need to end before volume should be restored\n              if (!this.audLock) this.audLock = 1;\n              else this.audLock++;\n\n              if (!this.props.riffsAudio.all[riff.id]) {\n                //(!riff.payload) {\n                return;\n              } // DEBUG - SHOULD BE REMOVED\n              var audioURL = URL.createObjectURL(\n                this.props.riffsAudio.all[riff.id]\n              ); //(riff.payload);\n              //debugger;\n\n              window.lastRiff = this.props.riffsAudio.all[riff.id]; // riff.payload;\n\n              // FIX THIS:\n\n              for (let i = 0; i < window.audioPlayersCount; i++) {\n                /*\n                if ( window.audioContexts[i].inUse ) continue;\n                let audioContext = window.audioContexts[i];\n                window.audioContexts[i].inUse = true;\n                var blob = riff.payload;\n                new Response(blob).arrayBuffer().then(function(arrayBuffer) {\n                  window.audioContexts[0].decodeAudioData(arrayBuffer, audioData => {\n                    debugger;\n                    var source = window.audioContexts[i].createBufferSource();\n                    source.buffer = audioData;\n                    source.connect(window.audioContexts[i].destination);\n                    source.start()\n                  })\n                });\n                */\n\n                let audio = window.audioPlayers[i];\n                if (audio.inUse) continue;\n                audio.inUse = true;\n\n                // TEST:\n                audio.srcEl.src = audioURL;\n                audio.load();\n                audio.play();\n\n                /*\n                var se = document.createElement('source');\n                audio.appendChild(se);\n                se.src = audioURL;\n                //se.type = 'audio/webm';\n                audio.load();\n                audio.play();\n                */\n\n                // ORIG:\n                /*\n                audio.src = audioURL;\n                audio.play();\n                */\n\n                this.curRiff[index] = audio; // audioContext;\n                break;\n              }\n            }\n          }\n        });\n      }, 100); // 100/1000 = 1/10 s\n\n      if (this.props.mode !== PLAY_MODE) {\n        // change mode state\n        this.props.setPlayerMode(PLAY_MODE);\n      }\n    } // not playing\n    else {\n      // stop riff-check interval when not playing\n      clearInterval(this.riffInterval);\n\n      if (this.props.mode === PLAY_MODE) {\n        // change mode state\n        this.props.setPlayerMode(PAUSE_MODE);\n      }\n    }\n  };\n\n  componentDidUpdate = (prevProps) => {\n    // seems needed on more than just mounting\n    // (makes sense; the riff meta takes some time to load)\n    this.checkForRiffsToLoad(0); // check if any riffs at < 10s in need loading\n\n    if (this.props.id !== prevProps.id) this.loadVideo();\n\n    if (!(this.player && this.player.getPlayerState)) return;\n\n    if (this.props.mode !== prevProps.mode) {\n      if (\n        (this.props.mode === EDIT_MODE ||\n          this.props.mode === EDIT_NEW_MODE ||\n          this.props.mode === PAUSE_MODE) &&\n        this.player.getPlayerState() === 1\n      ) {\n        this.player.pauseVideo();\n      } else if (\n        this.props.mode === PLAY_MODE &&\n        this.player.getPlayerState() !== 1\n      ) {\n        this.player.playVideo();\n      }\n    }\n  };\n\n  render = () => {\n    return (\n      <React.Fragment>\n        <div className=\"rifftube-container\">\n          <AllowPlayback />\n          <div className=\"rifftube-overlay\">\n            <div className=\"rifftube-riffs-container\">\n              {Object.keys(this.props.riffsPlaying)\n                .filter(\n                  (i) =>\n                    this.props.riffsPlaying[i] &&\n                    this.props.riffs[i] &&\n                    this.props.riffs[i].type === 'text'\n                )\n                .map((key) => (\n                  <div\n                    key={this.props.riffs[key].id}\n                    className=\"rifftube-textriff\"\n                  >\n                    {this.props.riffs[key].payload}\n                  </div>\n                ))}\n            </div>\n          </div>\n          <div id=\"rifftube-player\" />\n        </div>\n      </React.Fragment>\n    );\n  };\n}\n\nconst mapStateToProps = (state) => ({\n  mode: state.mode,\n  //riffs: state.riffs.all,\n  riffsPlaying: state.riffsPlaying,\n  googleUser: state.googleUser,\n  duration: state.duration,\n  riffsAudio: state.riffsAudio,\n});\n\nconst mapDispatchToProps = {\n  setPlayerMode,\n  setRiffPlaying,\n  togglePlayerMode,\n  loadRiff,\n  setVideoDuration,\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(YouTubeVideo);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}